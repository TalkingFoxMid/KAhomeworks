#include <stdio.h>
#include <stdlib.h>
#define ЧИСЛО int
#define БАЙТ char
#define ДЛИНОСЛОВ long
#define ВЗЯТЬПАМЯТЬ calloc
#define ДЛЯ for
#define ПОКА while
#define СЛОМАТЬСЯ break
#define ПРОДОЛЖИТЬ continue
#define ВЕРНУТЬ return
#define РАЗМЕР sizeof
#define ИЗУЧИТЬ_ДОКУМЕНТ fscanf
#define ГОЛОВА main
#define СОВПАДАЕТ_С ==
#define ЕСЛИ if
#define ДОКУМЕНТ FILE
#define НОЛЬ 0
#define ОДИН 1
#define ДВА 2
#define ТРИ 3
#define ЧЕТЫРЕ 4
#define В_ПРОТИВНОМ_СЛУЧАЕ else
#define ПЛЮС +
#define МИНУС -
#define СДЕЛАТЬ =
#define СОРОК_ВОСЕМЬ 48
#define ВВЕРХ 3862134
#define ВНИЗ 234152
#define ВЛЕВО 3251522
#define ВПРАВО 2345515
ЧИСЛО * ПУТЬ_ОБРАТНО(ЧИСЛО ВИД_ПУТИ) {
    ЧИСЛО * ПАРА = ВЗЯТЬПАМЯТЬ(2, РАЗМЕР(ЧИСЛО));
    ЕСЛИ (ВИД_ПУТИ == 2) {
        ПАРА[0] = 0;
        ПАРА[1] = 1;
        return ПАРА;
    }
    ЕСЛИ (ВИД_ПУТИ == 3) {
        ПАРА[0] = 0;
        ПАРА[1] = -1;
        return ПАРА;
    }
    ЕСЛИ (ВИД_ПУТИ == 4) {
        ПАРА[0] = 1;
        ПАРА[1] = 0;
        return ПАРА;
    }
    ЕСЛИ (ВИД_ПУТИ == 5) {
        ПАРА[0] = -1;
        ПАРА[1] = 0;
        return ПАРА;
    }
}
ЧИСЛО СПОСОБ_ДОБРАТЬСЯ(ЧИСЛО НАЧАЛО_СТРОКА,
                       ЧИСЛО НАЧАЛО_СТОЛБЕЦ,
                       ЧИСЛО КОНЕЦ_СТРОКА,
                       ЧИСЛО КОНЕЦ_СТОЛБЕЦ) {

    ЧИСЛО ДЕЛЬТА_СТРОКА = КОНЕЦ_СТРОКА - НАЧАЛО_СТРОКА;
    ЧИСЛО ДЕЛЬТА_СТОЛБЕЦ = КОНЕЦ_СТОЛБЕЦ - НАЧАЛО_СТОЛБЕЦ;
    ЕСЛИ (ДЕЛЬТА_СТРОКА == 0) {
        ЕСЛИ (ДЕЛЬТА_СТОЛБЕЦ == 1)
            ВЕРНУТЬ 2;
        В_ПРОТИВНОМ_СЛУЧАЕ ВЕРНУТЬ 3;
    } В_ПРОТИВНОМ_СЛУЧАЕ {
        ЕСЛИ (ДЕЛЬТА_СТРОКА == 1)
            ВЕРНУТЬ 4;
        В_ПРОТИВНОМ_СЛУЧАЕ ВЕРНУТЬ 5;
    };
}
ЧИСЛО ** ДОСТАТЬ_СОСЕДЕЙ(ЧИСЛО ВЫС, ЧИСЛО ШЫР, ЧИСЛО ** ГРАФ,
                        ЧИСЛО СТРОКА, ЧИСЛО СТОЛБЕЦ) {
    ЧИСЛО КОЛИЧЕСТВО_СОСЕДЕЙ = 0;
    ЧИСЛО ** СОСЕДИ = ВЗЯТЬПАМЯТЬ(ЧЕТЫРЕ, РАЗМЕР(ДЛИНОСЛОВ));
    ЕСЛИ (СТРОКА СОВПАДАЕТ_С НОЛЬ) {
        СОСЕДИ[НОЛЬ] СДЕЛАТЬ НОЛЬ;
    } В_ПРОТИВНОМ_СЛУЧАЕ {
        БАЙТ СОСЕД = ГРАФ[СТРОКА МИНУС ОДИН][СТОЛБЕЦ];
        ЕСЛИ (СОСЕД СОВПАДАЕТ_С НОЛЬ) {
            СОСЕДИ[НОЛЬ] СДЕЛАТЬ ВЗЯТЬПАМЯТЬ(ДВА, РАЗМЕР(ЧИСЛО));
            СОСЕДИ[НОЛЬ][0] = СТРОКА МИНУС ОДИН;
            СОСЕДИ[НОЛЬ][1] = СТОЛБЕЦ;
            КОЛИЧЕСТВО_СОСЕДЕЙ++;
        }


    }
    ЕСЛИ (СТРОКА СОВПАДАЕТ_С ВЫС МИНУС ОДИН) {
        СОСЕДИ[ОДИН] СДЕЛАТЬ НОЛЬ;
    } В_ПРОТИВНОМ_СЛУЧАЕ {
        БАЙТ СОСЕД СДЕЛАТЬ ГРАФ[СТРОКА ПЛЮС ОДИН][СТОЛБЕЦ];
        ЕСЛИ (СОСЕД СОВПАДАЕТ_С НОЛЬ) {
            СОСЕДИ[ОДИН] СДЕЛАТЬ ВЗЯТЬПАМЯТЬ(ДВА, РАЗМЕР(ЧИСЛО));
            СОСЕДИ[ОДИН][0] = СТРОКА ПЛЮС ОДИН;
            СОСЕДИ[ОДИН][1] = СТОЛБЕЦ;
            КОЛИЧЕСТВО_СОСЕДЕЙ++;
        }

    }
    ЕСЛИ (СТОЛБЕЦ СОВПАДАЕТ_С НОЛЬ) {
        СОСЕДИ[ДВА] СДЕЛАТЬ НОЛЬ;
    } В_ПРОТИВНОМ_СЛУЧАЕ {
        БАЙТ СОСЕД СДЕЛАТЬ ГРАФ[СТРОКА][СТОЛБЕЦ МИНУС ОДИН];
        ЕСЛИ (СОСЕД СОВПАДАЕТ_С НОЛЬ) {
            СОСЕДИ[ДВА] СДЕЛАТЬ ВЗЯТЬПАМЯТЬ(ДВА, РАЗМЕР(ЧИСЛО));
            СОСЕДИ[ДВА][0] = СТРОКА;
            СОСЕДИ[ДВА][1] = СТОЛБЕЦ МИНУС ОДИН;
            КОЛИЧЕСТВО_СОСЕДЕЙ++;
        }
    }
    ЕСЛИ (СТОЛБЕЦ СОВПАДАЕТ_С ШЫР МИНУС ОДИН) {
        СОСЕДИ[ТРИ] СДЕЛАТЬ НОЛЬ;
    } В_ПРОТИВНОМ_СЛУЧАЕ {
        БАЙТ СОСЕД СДЕЛАТЬ ГРАФ[СТРОКА][СТОЛБЕЦ ПЛЮС ОДИН];
        ЕСЛИ (СОСЕД СОВПАДАЕТ_С НОЛЬ) {
            СОСЕДИ[ТРИ] СДЕЛАТЬ ВЗЯТЬПАМЯТЬ(ДВА, РАЗМЕР(ЧИСЛО));
            СОСЕДИ[ТРИ][0] = СТРОКА;
            СОСЕДИ[ТРИ][1] = СТОЛБЕЦ ПЛЮС ОДИН;
            КОЛИЧЕСТВО_СОСЕДЕЙ++;
        }
    }
    ВЕРНУТЬ СОСЕДИ;
}

БАЙТ * СЧИТАТЬ_СТРОКУ(ДОКУМЕНТ * ОТКУДА_СЧИТЫВАТЬ) {
    БАЙТ * ПОДВАЛ = ВЗЯТЬПАМЯТЬ(256, РАЗМЕР(БАЙТ));
    БАЙТ * ПОДВАЛ_ПОЙНТЕР = ПОДВАЛ;
    БАЙТ СИМВОЛ;

    ПОКА(СИМВОЛ = fgetc(ОТКУДА_СЧИТЫВАТЬ)) {
        ЕСЛИ (СИМВОЛ СОВПАДАЕТ_С '\n' || СИМВОЛ СОВПАДАЕТ_С -1) {
            СЛОМАТЬСЯ;
        }

        *ПОДВАЛ_ПОЙНТЕР = СИМВОЛ;
        ПОДВАЛ_ПОЙНТЕР++;
    }
    ВЕРНУТЬ ПОДВАЛ;
}

ЧИСЛО ГОЛОВА() {

    ДОКУМЕНТ * ЗАДОКУМЕНТИРОВАННЫЙ_ГРАФ = fopen("maze1","r");

    ЧИСЛО ВЫС;
    ЧИСЛО ШЫР;
    БАЙТ БУФФЕР[256];

    ИЗУЧИТЬ_ДОКУМЕНТ(ЗАДОКУМЕНТИРОВАННЫЙ_ГРАФ,"%d", &ВЫС);
    ИЗУЧИТЬ_ДОКУМЕНТ(ЗАДОКУМЕНТИРОВАННЫЙ_ГРАФ,"%d", &ШЫР);
    fgetc(ЗАДОКУМЕНТИРОВАННЫЙ_ГРАФ); // КОНТРОЛЬНОЕ СЧИТЫВАНИЕ
    ЧИСЛО ** ГРАФ = ВЗЯТЬПАМЯТЬ(ВЫС, РАЗМЕР(ДЛИНОСЛОВ));
    ДЛЯ (ЧИСЛО И = 0; И < ВЫС; ++И) {

        ГРАФ[И] = ВЗЯТЬПАМЯТЬ(ВЫС, РАЗМЕР(БАЙТ));
        БАЙТ * СТРУКАЗАТЕЛЬ = СЧИТАТЬ_СТРОКУ(ЗАДОКУМЕНТИРОВАННЫЙ_ГРАФ);
        ЧИСЛО СЧЁТЧИК = 0;
        ПОКА(*СТРУКАЗАТЕЛЬ) {
            ЕСЛИ (*СТРУКАЗАТЕЛЬ СОВПАДАЕТ_С 0)
                СЛОМАТЬСЯ;
            ЕСЛИ (*СТРУКАЗАТЕЛЬ СОВПАДАЕТ_С ' ') {
                СТРУКАЗАТЕЛЬ++;
                ПРОДОЛЖИТЬ;
            }
            ГРАФ[И][СЧЁТЧИК] = *СТРУКАЗАТЕЛЬ-СОРОК_ВОСЕМЬ;
            СЧЁТЧИК++;
            СТРУКАЗАТЕЛЬ++;
        }
    }
    БАЙТ * СТАРТОВАЯ_ПОЗИЦИЯ = СЧИТАТЬ_СТРОКУ(ЗАДОКУМЕНТИРОВАННЫЙ_ГРАФ);
    ЧИСЛО СТРОКА_НАЧАЛА;
    ЧИСЛО СТОЛБЕЦ_НАЧАЛА;
    sscanf(СТАРТОВАЯ_ПОЗИЦИЯ, "%d %d", &СТРОКА_НАЧАЛА, &СТОЛБЕЦ_НАЧАЛА);
    СТРОКА_НАЧАЛА--;
    СТОЛБЕЦ_НАЧАЛА--;

    ЧИСЛО ** ОЧЕРЕДЬ = ВЗЯТЬПАМЯТЬ(1000, РАЗМЕР(ДЛИНОСЛОВ));
    ЧИСЛО ** НАЧАЛО_ОЧЕРЕДИ = ОЧЕРЕДЬ;
    ЧИСЛО ** КОНЕЦ_ОЧЕРЕДИ = ОЧЕРЕДЬ;
    ЧИСЛО РАЗМЕР_ОЧЕРЕДИ = 1;
    *ОЧЕРЕДЬ = ВЗЯТЬПАМЯТЬ(2, РАЗМЕР(ЧИСЛО));
    (*ОЧЕРЕДЬ)[0] = СТРОКА_НАЧАЛА;
    (*ОЧЕРЕДЬ)[1] = СТОЛБЕЦ_НАЧАЛА;
    ПОКА (РАЗМЕР_ОЧЕРЕДИ > 0) {
        ЧИСЛО * ПОЗИЦИЯ_ПОИСКА = *НАЧАЛО_ОЧЕРЕДИ;
        НАЧАЛО_ОЧЕРЕДИ++;
        РАЗМЕР_ОЧЕРЕДИ--;
        ЧИСЛО СТРОКА_ПОИСКА = ПОЗИЦИЯ_ПОИСКА[0];
        ЧИСЛО СТОЛБЕЦ_ПОИСКА = ПОЗИЦИЯ_ПОИСКА[1];
        ЧИСЛО ** ДОСТАННЫЕ_СОСЕДИ = ДОСТАТЬ_СОСЕДЕЙ(ВЫС, ШЫР, ГРАФ,
                                                   СТРОКА_ПОИСКА,
                                                   СТОЛБЕЦ_ПОИСКА);
        for (int i = 0; i < 4; ++i) {
            ЕСЛИ (ДОСТАННЫЕ_СОСЕДИ[i] != 0) {
                КОНЕЦ_ОЧЕРЕДИ++;
                (*КОНЕЦ_ОЧЕРЕДИ) = ДОСТАННЫЕ_СОСЕДИ[i];
                РАЗМЕР_ОЧЕРЕДИ++;
                ЧИСЛО СТРОКА_СОСЕДА = ДОСТАННЫЕ_СОСЕДИ[i][0];
                ЧИСЛО СТОЛБЕЦ_СОСЕДА = ДОСТАННЫЕ_СОСЕДИ[i][1];
                ЧИСЛО ПУТЬ = СПОСОБ_ДОБРАТЬСЯ(СТРОКА_ПОИСКА,
                                              СТОЛБЕЦ_ПОИСКА,
                                              СТРОКА_СОСЕДА,
                                              СТОЛБЕЦ_СОСЕДА);
                ГРАФ[СТРОКА_СОСЕДА][СТОЛБЕЦ_СОСЕДА] = ПУТЬ;
            }
        }
    }
    БАЙТ * КОНЕЧНАЯ_ПОЗИЦИЯ = СЧИТАТЬ_СТРОКУ(ЗАДОКУМЕНТИРОВАННЫЙ_ГРАФ);
    ЧИСЛО СТРОКА_КОНЦА;
    ЧИСЛО СТОЛБЕЦ_КОНЦА;
    sscanf(КОНЕЧНАЯ_ПОЗИЦИЯ, "%d %d", &СТРОКА_КОНЦА, &СТОЛБЕЦ_КОНЦА);
    СТРОКА_КОНЦА--;
    СТОЛБЕЦ_КОНЦА--;

    ЕСЛИ (ГРАФ[СТРОКА_КОНЦА][СТОЛБЕЦ_КОНЦА] == 0) {
        printf("N");
        ВЕРНУТЬ 0;
    }
    ЧИСЛО ТЕКУЩАЯ_СТРОКА = СТРОКА_КОНЦА;
    ЧИСЛО ТЕКУЩИЙ_СТОЛБЕЦ = СТОЛБЕЦ_КОНЦА;
    printf("Y\n");
    ЧИСЛО ** ОТВЕТ = ВЗЯТЬПАМЯТЬ(1000, РАЗМЕР(ДЛИНОСЛОВ));
    ЧИСЛО ** ОТВЕТ_НАЧАЛО = ОТВЕТ;
    ПОКА(ТЕКУЩАЯ_СТРОКА != СТРОКА_НАЧАЛА || ТЕКУЩИЙ_СТОЛБЕЦ != СТОЛБЕЦ_НАЧАЛА) {
        ЧИСЛО * ШАГ = ПУТЬ_ОБРАТНО(ГРАФ[ТЕКУЩАЯ_СТРОКА][ТЕКУЩИЙ_СТОЛБЕЦ]);
        ЧИСЛО ШАГ_СТРОКИ = ШАГ[0];
        ЧИСЛО ШАГ_СТОЛБЦА = ШАГ[1];
        (*ОТВЕТ) = ВЗЯТЬПАМЯТЬ(2, РАЗМЕР(ДЛИНОСЛОВ));
        (*ОТВЕТ)[0] = ТЕКУЩАЯ_СТРОКА+1;
        (*ОТВЕТ)[1] = ТЕКУЩИЙ_СТОЛБЕЦ+1;
        ТЕКУЩАЯ_СТРОКА -= ШАГ_СТРОКИ;
        ТЕКУЩИЙ_СТОЛБЕЦ -= ШАГ_СТОЛБЦА;

        ОТВЕТ++;
    }
    (*ОТВЕТ) = ВЗЯТЬПАМЯТЬ(2, РАЗМЕР(ДЛИНОСЛОВ));
    (*ОТВЕТ)[0] = ТЕКУЩАЯ_СТРОКА+1;
    (*ОТВЕТ)[1] = ТЕКУЩИЙ_СТОЛБЕЦ+1;

    while (ОТВЕТ != ОТВЕТ_НАЧАЛО-1) {
        printf("%d %d\n", (*ОТВЕТ)[0], (*ОТВЕТ)[1]);
        ОТВЕТ--;
    }
    ВЕРНУТЬ 0;
}
